## 本章内容

> 使用对象
>
> 创建并操作数组
>
> 理解基本的JavaScript类型
>
> 使用基本类型和基本包装类型

### 5.1 Object 类型

Object 类型是 ECMAScript 中使用最多的一个类型，创建 Object 有两种方式：

```javascript
var person = new Object(); // 方法1、使用new操作符
var person = {name: '张三'}; // 方法2、使用对象字面量表示法
```

通过对象字面量表示法构建的对象不会调用构造函数。

使用对象字面量给函数传参是非常灵活的，形如下面：

```javascript
// 这种传参方式适用于不确定函数需要几个参数
// 或者参数很多，但不是每次都需要这么多，参数的顺序也不确定的情况下
var fn = function(opts){
    opts.x = opts.x || 1;
    opts.y = opts.y || 2;
}
```

访问对象属性有两种方式：

> 1、点表示法：`person.name`
>
> 2、方括号表示法：`person["first name"]`，这个方式在点表示法的基础上，还能支撑不规则的属性名

### 5.2 Array 类型

ECMAScript 的数组的每一项可以保存任何类型的数据，且数组的大小可以随着数组长度的变化自动调整。

创建数组也有两种方式：

```javascript
var arr = new Array(); // 1、使用 new 操作符
var arr = []; // 2、使用数组字面量表示法
```

不要写成下面这样的：

```javascript
var arr = [1,2,]; // 这会创建一个包含2项或3项的数组，IE为2，chrome70为2，chrome72为3
```

与对象一样，数组字面量也不会调用 Array 构造函数。

要访问和设置数组的值，只有方括号索引这一种方法。

> 可以通过改变数组的length属性的值来改变数组可访问的范围

数组最多可以包含 4294967295 项，超过这个上限会报错，接近这个上限会导致运行时间超长的脚本错误。

#### 5.2.1 检测数组

有两种方法：

```javascript
value instanceof Array; // 方法1、
Array.isArray(value); // 方法2，isArray()是es5的
```

#### 5.2.2 转换方法

介绍了 `toLocaleString()` 、`toString()`、`valueOf` 三个方法。

> 所有对象都有 `toLocaleString()` 、`toString()`、`valueOf` 方法。
>
> 调用数组的 `toString()` 方法会返回由数组每个值的字符串形式拼接而成的一个以逗号隔开的字符串。
>
> 调用数组的 `valueOf()` 方法返回的还是数组。

**toString()：**

数组的该方法无参数，把数组元素以逗号分隔组成为一个字符串并返回

```javascript
var arr = [1,2,3,4];
arr.toString(); // '1,2,3,4'
```

`toString()` 和 `join([separator])` 的区别：

> toString() 方法无参数，默认以逗号分隔
>
> join()可传参，参数为分隔符，默认为逗号

在处理多维数组时，join()还是不如toString()的：

```javascript
var arr1 = [1,2,3,[4,5,6]];
arr1.join('*'); // "1*2*3*4,5,6"
arr1.join(','); // "1,2,3,4,5,6"
arr1.toString(); // "1,2,3,4,5,6"
```

**valueOf()：** 

无参数，返回数组本身。

**toLocaleString([locales[,options]])：** 

有两个可选参数。数组中的元素将使用各自的 `toLocaleString` 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 ","）隔开。

> toLocaleString() 方法在 chrome 版本 72.0.3626.119（正式版本） （64 位）下有bug，数组的toLocaleString()返回空字符串，IE和chrome 72都是ok的

如果数组中的某一项值是 `null` 或 `undefined` ，那么该值在 `join()`、`toLocaleString()`、`toString()`方法返回的结果中以空字符串表示。

#### 5.2.3 栈方法

**栈** 是一种 **LIFO**（Last-In-First-Out，后进先出）的数据结构，最新添加的数据最早被移除。

ECMAScript 为数据提供了 `pop()`和`push()` 方法，使得数组可以实现类似 **栈** 的行为。

> `push()` 方法接收任意类型的参数并将其推入到数组末尾，并返回修改后的数组的长度。
>
> `pop()` 方法从数组末尾移除最后一项，减少数组的长度，并返回移除的项。

以下代码的数组可以看成是栈：

```js
var colors = new Array();
var count = colors.push("red", "blue");
console.log(count); // 2

count = colors.push("black");
console.log(count); // 3

var item = colors.pop();
console.log(item); // "black"
```

#### 5.2.4 队列方法

**队列** 是一种 **FIFO** （First-In-First-Out，先进先出）的数据结构。队列在列表的末端添加数据，在列表的前端移除数据，就像现实中的排队一样。

使用数组实现队列需要用到 `push()`和 `shift()` 

> `push()` 方法接收任意类型的参数并将其推入到数组末尾，并返回修改后的数组的长度。
>
> `shift()` 方法移除数组的第一项，并将数组的长度减1，同时返回移除的项。

以下代码的数组可以看成是队列：

```js
var colors = new Array();
var count = colors.push("red", "blue");
console.log(count); // 2

count = colors.push("black");
console.log(count); // 3

var item = colors.shift();
console.log(item); // "red"
```

ECMAScript 还提供了 `unshift()` 方法，与 `shift()` 方法相反，`unshift()` 方法可以在数组前端添加任意个项并返回数组的长度。

> 因此，使用 `unshift()` 和 `pop()` 方法可以实现反向队列。

#### 5.2.5 重排序方法

数组中提供了两种重排序方法：`reverse()` 和 `sort()` 。

> `reverse()` 方反转数组项的顺序。
>
> `sort()` 方法默认按升序排列数组，即最小值排前面，最大值排后面。为了实现排序，`sort()`方法会调用数组每项的`toString()`方法转换，然后比较每一项以确定如何顺序。
>
> > 即使数组的项是数值，`sort()` 方法比较的也是字符串。

`sort()`方法的默认排序有一些问题，如下：

```js
var arr = [1, 5, 10, 2];
arr.sort();
console.log(arr); // 1， 10， 2， 5
```

因为`sort()` 会把数组的每一项转为字符串，字符串形式的`5`和`2` 都大于`10`。

为了解决这种问题，`sort` 方法可以接收一个比较函数作为参数，以便于我们指定哪个项排列在前面：

```js
var arr = [1, 5, 10, 2];
// 默认升序，所以这里的 a - b 表示的是 a 是否小于 b； b - a 表示降序
arr.sort(function(a, b){ return a - b });
console.log(arr); // 1， 2, 5, 10
```

**注意：** `reverse()` 和  `sort()` 方法的返回值是排序后的数组。

#### 5.2.6 操作方法

ECMAScript 还提供了很多操作数组的方法。

**`concat()`**，先创建当前数组的副本，然后将接收到的参数添加到副本的末尾，最后返回新构建的数组。

```js
var arr = [1, 2, 3];
var arr2 = arr.concat([4, 5, 6]);
console.log(arr2); // [1, 2, 3, 4, 5, 6]
```

**`slice()`**，基于当前数组中的一或多项创建一个新数组。改方法可以接收一个或两个参数：`arr.slice([begin[, end]])`。返回由被提取元素组成的新数组，并不会改变原数组。

> `begin`，可选。
>
> > 提取项开始的索引，默认为0。
> >
> > 如果为负数，则从倒数索引开始，如`slice(-2)`表示从倒数第2项到最后一个元素（包含最后一个）。
> >
> > 如果该值大于数组长度，则返回空数组。
>
> `end`，可选。该值如果省略就是闭区间，有的情况下就是开区间。
>
> > 提取项终止的索引，默认为数组最后一项，且包含最后一项。
> >
> > `slice(1, 3)` 提取数组第2项到第3项之间的所有项，包含第2项、第3项，不包含第4项。
> >
> > 如果为负数，则从倒数索引开始，如`slice(-2, -1)` 取倒数第2项到最后一项之间的项，包含倒数第2项，不包含最后一项。

```js
var arr = [1, 2, 3];
var arr2 = arr.slice(); // 没有起始，则返回整个数组
console.log(arr2); // [1, 2, 3]
console.log(arr); // [1, 2, 3]，slice() 不会改变原数组

arr2 = arr.slice(1); // 从第2项开始
console.log(arr2); // [2, 3]
arr2 = arr.slice(0, 1); // 从第1项开始截取，到第2项前截止，不包含第2项
console.log(arr2); // [1]
```

**`splice()`**，该方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。

传参如下：

```js
array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
```

`start` 必填参数，指定修改的开始位置。

> 如果超出了数组的长度， 则从数组末尾开始添加内容。
>
> 如果是负值，则表示倒数第几位。
>
> 如果负数的绝对值超过数组的长度，则从0开始。

`deleteCount`，可选，整数，表示要删除的数组元素的个数。

> 如果该值缺省或该值大于`start`之后的数的长度，则`start`之后的数全部被删除（含`start`）
>
> 如果该值为0或者负数，则不删除元素。

`item1`、`item2`... 可选。

> 可以从 `start` 开始添加新元素

返回值

> 由被删除的元素组成的新数组。
>
> 添加元素的时候返回的是空数组。

```js
var arr = [1, 2, 3];
var arr2 = arr.splice(1, 1); // arr2：[2]
var arr3 = arr.splice(1,0,4); // arr：[1, 4, 3]、arr3：[]
```

#### 5.2.7 位置方法

ECMAScript 5 为数组提供了两个位置方法：`indexOf()` 和 `lastIndexOf()`。

**`indexOf()`**方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。

语法：

```js
arr.indexOf(searchElement[, fromIndex = 0])
```

`searchElement`，必填

> 要查找的元素

`fromIndex`，可选

> 开始查找的位置，默认为0。
>
> 如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。
>
> 如果参数中提供的索引值是一个负值，则从倒数位置开始查找，如`fromIndex=-2`表示从倒数第2项开始 。

返回值

> 首个被找到的元素在数组中的索引位置;
>
> 若没有找到则返回 -1

```js
var arr = [1, 2, 3];
arr.indexOf(2); // 1
```

**`lastIndexOf()`** 方法返回指定元素在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 `fromIndex` 处开始。

语法

```js
arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])
```

`searchElement`，必填

> 要查找的元素

`fromIndex`，可选

> 开始查找的位置逆向查找，默认为数组长度减1。
>
> 如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。
>
> 如果参数中提供的索引值是一个负值，则从前面开始查找开始查找，如`fromIndex=-2`表示从第2项开始 。

返回值

> 数组中最后一个匹配元素的索引位置;
>
> 若没有找到则返回 -1

```js
var array = [2, 5, 9, 2];
var index = array.lastIndexOf(2); // 3
```

#### 5.2.8 迭代方法

ECMPScript 5 为数组定义了5个迭代方法。分别是： `every()`、`some()`、`filter()`、`forEach()`、`map()`。

**`every()`** 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

> 若收到一个空数组，此方法在一切情况下都会返回 `true`。

语法

```js
arr.every(callback[, thisArg])
```

`callback`，必填。用来测试每个元素的函数，它可以接收三个参数：

> `element`
>
> 用于测试的当前值。
>
> `index`，可选
>
> 用于测试的当前值的索引。
>
> `array`，可选
>
> 调用 `every` 的当前数组。

`thisArg`，可选

>  执行 `callback` 时使用的 `this` 值。

返回值

> 如果回调函数的每一次返回都为 [truthy](https://developer.mozilla.org/en-US/docs/Glossary/truthy) 值，返回 `true` ，否则返回 `false`。

```js
// 下例检测数组中的所有元素是否都大于 10。
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough);   // false
[12, 54, 18, 130, 44].every(isBigEnough); // true
```

**`some()`** 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。

> 在语法、参数、返回值上，`some()` 和 `every()` 是一样的，他们唯一的区别就是满足条件。
>
> > `every()` 需要数组中的每一项都满足条件才会返回`true`
> >
> > `some()` 只需要数组中的有一项满足条件就会返回 `true`

```js
// 下例检测数组中的所有元素是否都大于 10。
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].some(isBigEnough);   // true
[12, 54, 18, 130, 44].some(isBigEnough); // true
```

**`filter()`** 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 

> 在语法、参数上，`fileter()`与`every()` 是一样的。

返回值

> 一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。

```js
// 下例检测数组中的所有元素是否都大于 10。
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].filter(isBigEnough);   // [12, 130, 44]
```

关于`forEach()` 和 `map()`，在[另一篇](<https://juejin.im/post/5c0e0e5af265da61650166ca>)里面与`reduce()`进行了对比，这里就不重复了。

#### 5.2.9 归并方法

