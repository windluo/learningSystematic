## 第2章 、Scope & Closures（作用域和闭包）

### 2.1 什么是作用域

几乎所有的编程语言都将值存储于变量中，然后通过变量检索或修改这些值。通过一套定义明确的规则，将变量存储在某个位置，并在以后找到这些变量。这套规则称为：作用域。

#### 2.1.1 编译理论

尽管 JavaScript 是动态类型语言（或解释类型语言），JavaScript 引擎还是会对它进行一系列的编译，就像其它语言那样。编译语言的程序源代码块通常在执行前经历三个步骤，即“编译”：

1. **分词/词法分析：** 将一连串字符打断成（对于语言来说）有意义的片段，称为 token（记号）。举例来说，考虑这段程序：`var a = 2;`。这段程序很可能会被打断成如下 token：`var`，`a`，`=`，`2`，和 `;`。空格也许会被保留为一个 token，这要看它是否是有意义的。

   **注意：** 分词和词法分析之间的区别是微妙和学术上的，其中心在于这些 token 是否以 *无状态* 或 *有状态* 的方式被识别。简而言之，如果分词器去调用有状态的解析规则来弄清`a`是否应当被考虑为一个不同的 token，还是只是其他 token 的一部分，那么这就是 **词法分析**。

2. **解析：** 将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为“抽象语法树”（AST —— **A**bstract **S**yntax **T**ree）。

   `var a = 2;` 的树也许开始于称为 `VariableDeclaration`（变量声明）顶层节点，带有一个称为 `Identifier`（标识符）的子节点（它的值为 `a`），和另一个称为 `AssignmentExpression`（赋值表达式）的子节点，而这个子节点本身带有一个称为 `NumericLiteral`（数字字面量）的子节点（它的值为`2`）。

3. **代码生成：** 这个处理将抽象语法树转换为可执行的代码。这一部分将根据语言，它的目标平台等因素有很大的不同。

   所以，与其深陷细节，我们不如笼统地说，有一种方法将我们上面描述的 `var a = 2;` 的抽象语法树转换为机器指令，来实际上 *创建* 一个称为 `a` 的变量（包括分配内存等等），然后在 `a` 中存入一个值。

   **注意：** 引擎如何管理系统资源的细节远比我们要挖掘的东西深刻，所以我们将理所当然地认为引擎有能力按其需要创建和存储变量。

上面这三个步骤还只是完整编译过程的大概，实际的编译要比这复杂的多。JavaScript 引起为了保证性能，做了各种优化，其编译速度是非常快的，快到我们开发人员根本无需关心这个编译细节。

> 对于开发人员而言，JS 编译器拿到代码块`var a = 2;`，首先编译它，然后运行它，就是这样。

#### 2.1.2 理解作用域

处理代码块`var a = 2;`涉及下面三个概念：

- **引擎**，负责从始至终的编译和执行我们的 JavaScript 程序。
- **编译器**，引擎的的朋友之一； 处理所有繁琐的解析和代码生成工作。
- **作用域**，*引擎* 的另一个朋友；收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。

对于代码块`var a = 2;`，根据上面的概念，实际执行时有如下两个步骤：

- 编译器首先会在作用域内查找变量`a`，如果存在则继续，不存在则声明一个变量`a`，然后继续下一步——编译器为引擎生成稍后要执行的代码。
- 引擎执行代码，先在作用域内查找变量`a`，当前作用域找不到就到*可访问的上层作用域（作用域链）*查找，找到了就执行赋值语句`a=2`，找不到变量`a`就报错。

**注意：** 在 JS 中，如果未声明的变量前面没有`var`这种声明性的关键字，编译器会把变量声明挂载到全局对象`window`上。引擎找不到变量报错的情况，目前能想到的是引用类型的变量上找不到对应的属性，给该属性赋值会报错。基本类型的变量应该都会挂到`window`上。

#### 2.1.3 编译器术语

这里讲到了什么是“左值”和“右值”，也就是左查询（Left-hand Side，LHS）和右查询（Right-hand Side，RHS）。

简单来说，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。

> RHS 的意思是“去取……的值”。

从概念上可以理解为：“赋值的目标（LHS）”和“赋值的源（RHS）”。

### 总结

- 作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找（可以使用的范围）。
- 左值 - 赋值的目标（LHS）
- 右值 - 赋值的源（RHS）

### 2.2 词法作用域

词法作用域是 JavaScript 所采用的作用域模型。词法作用域意味着作用域是由编写时函数被声明的位置的决策定义的。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询。

**一旦找到第一个匹配，作用域查询就停止了**。相同的标识符名称可以在嵌套作用域的多个层中被指定，这称为“遮蔽（shadowing）”（内部的标识符“遮蔽”了外部的标识符）。无论如何遮蔽，作用域查询总是从当前被执行的最内侧的作用域开始，向外/向上不断查找，直到第一个匹配才停止。

`eval(..)` 和 `with` 会修改/创建词法作用域，压制了 *引擎* 在作用域查询上进行编译期优化的能力，导致代码运行变慢，所以不要使用它们。

### 2.3 函数与快作用域

在 JavaScript 中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”。

函数绝不是唯一的作用域单位。块作用域指的是这样一种想法：变量和函数可以属于任意代码块（一般来说，就是任意的 `{ .. }`），而不是仅属于外围的函数。

从 ES3 开始，`try/catch` 结构在 `catch` 子句上拥有块作用域。

在 ES6 中，引入了 `let` 关键字（`var` 关键字的表兄弟）允许在任意代码块中声明变量。`if (..) { let a = 2; }` 将会声明变量 `a`，而它实质上劫持了 `if` 的 `{ .. }` 块的作用域，并将自己附着在这里。

### 2.4 提升

我们可能被诱导而将 `var a = 2` 看作是一个语句，但是 JavaScript *引擎* 可不这么看。它将 `var a` 和 `a = 2` 看作两个分离的语句，第一个是编译期的任务，而第二个是执行时的任务。

声明本身会被提升，但不是赋值，即便是函数表达式的赋值，也 *不会* 被提升。所以下面代码会报错

```js
// 函数声明会被提升，但是函数表达式不会。
foo(); // 不是 ReferenceError， 而是 TypeError! 在foo被声明为函数之前提升了，此时的 foo 是 undefined

var foo = function bar() {
	// ...
};
```

所以在使用变量和函数之前一定要声明并赋值好！

### 2.5 作用域闭包

闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。

```js
function foo() {
	var a = 2;

	function bar() {
		console.log( a );
	}

	return bar;
}

var baz = foo();

baz(); // baz 实际调用的是闭包 bar
```



### 总结

关于作用域和闭包，红宝书（第7章-函数表达式）讲的更加浅显易懂。YDKJS这一章节关于左值和右值讲的还算不错。

从目前看完的章节来看，YDKJS太多口语化的描述，有些东西讲的比较绕且晦涩，不如红宝书。

YDKJS偏编译器方面的涉及还是不错的。还结合了ES6。