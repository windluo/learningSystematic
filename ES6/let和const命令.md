## let 和 const 命令

### 基础用法

声明变量的方式跟`var`一样，作用域有区别。

`let`和`const`声明的变量只在其块级作用域有效

> 比如`for`循环体的自增变量`i`，`var`声明的会挂在全局作用域下，循环体外可见，且是最后一次的值；`let`声明的仅在循环体内可见，且每次循环结束都是全新的值。

`for`循环体的作用域：

```js
for (let i = 0; i < 3; i++) // 代码块1
{// 代码块2
  // 1、2的变量处于两个不同的作用域
  let i = 'abc';
  console.log(i);
}
```

let 和 const 命令有以下特点：

- 不存在变量提升
- 暂时性死区
- 不允许重复声明

#### 不存在变量提升

`var`声明的变量可以在声明之前就使用，JS 引擎在解析代码时会把变量声明提升到使用前，只是还没有进行赋值，这种逻辑当然是不合理的，所以 ES6 在引入`let`和`const`时取消了这个逻辑。

> 当然，用`var`声明的变量依然存在变量提升

#### 暂时性死区

`let`和`const`声明的变量，会在其作用域内形成封闭的区间，只要在声明之前使用了变量就会报错。这个其实就是为了限制变量提升的问题。

这种情况下，提前使用`typeof`将会报错。

#### 不允许重复声明

即在同一作用域下，`let`和`const`不允许声明相同的变量。

```js
{
	let x = 1;
    let x = 2;
}
// Uncaught SyntaxError: Identifier 'x' has already been declared
```

### 为什么需要块级作用域

ES5没有块级作用域的概念，只有全局作用域和函数作用域，这引发了很多问题。

第一种，内层变量可能会覆盖外层变量。

```js
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
```

因为`var`有变量提升的特性，导致内层的变量`tmp`覆盖了全局的变量`tmp`，又因为内层的`tmp`赋值前被`false`判定，无法赋值，所以输出`undefined`。

> 函数作用域干扰到全局作用域。函数内不影响。
>
> 换成`let`则不会有影响。

第二种，则是经典的`for`循环变量`i`泄露为全局变量。

在 ES6 引入`let`和`const`后，块级作用域也被引入，以`{}`区分代码块，可以嵌套，每一代码块是一个块级作用域，变量彼此互不影响。

### const 的一点区别

使用方法上`const`和`let`是一样，区别在`const`声明的变量必需同时赋值，声明时不赋值会报错。

`const`保证的是变量指向的内存地址不可变，并不是值不可变。

> 基础类型数据的内存地址和数据都在同一个内存空间，改值就相当于改地址，所以会报错。
>
> 引用类型数据的内存地址和数据存在不同内存空间，`const`类型无法保证其数据不变。
>
> > 想要冻结引用类型数据，推荐使用`Object.freeze`方法。

### 全局对象

在 ES5 中，全局对象跟全局变量是同一个东西。这导致了一些问题：

- 编译时不能报错变量未声明，因为有变量提升
- 全局对象的属性可以到处读写，不利于模块化编程

在 JS 中，全局对象如`window`、`document`等。ES6中将全局对象和全局变量区分开，同时为了保持兼容，`var`和`function`声明的全局变量依然是全局对象的属性，`let`、`const`、`class`声明的全局变量不是全局对象的属性，而是独属于一个类似`Global`的全局变量对象。

